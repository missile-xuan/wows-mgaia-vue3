glViewer = function (params) {
  var self = this
  this.params = params
  this.basePath = ''
  this.model = []
  this.mouse = new THREE.Vector2()
  this.container = document.getElementById(params.container)
  this.container.addEventListener('mousemove', this.mouseMove, false)
  this.busyIcon = document.createElement('div')
  this.busyIcon.className = 'glviewer_busy_icon spinner'
  this.container.appendChild(this.busyIcon)
  this.fullScreenButton = document.createElement('img')
  this.fullScreenButton.className = 'glviewer_fullscreen_icon'
  this.fullScreenButton.src = '/images/glviewer_icon_fullscreen.png'
  this.fullScreenButton.onclick = function () {
    self.fullScreen()
  }
  this.container.appendChild(this.fullScreenButton)
  this.controlPanel = document.createElement('div')
  this.controlPanel.className = 'glviewer_control_panel'
  this.container.appendChild(this.controlPanel)
  this.fpsViewer = document.createElement('p')
  this.controlPanel.appendChild(this.fpsViewer)
  this.infoPanel = document.createElement('div')
  this.infoPanel.className = 'glviewer_info_panel'
  this.infoPanel.style.display = 'none'
  this.container.appendChild(this.infoPanel)
  this.optionsPanel = document.createElement('div')
  this.optionsPanel.className = 'glviewer_info_panel'
  this.optionsPanel.innerHTML =
    '<div>' +
    '<h3>Options</h3>' +
    '<hr>' +
    "<div>Ambient<br><input type='range' id='optAmbient' min='0' max='2' step=0.1 onInput=\"self.setAmbient()\"></div>" +
    "<div>Lighting<br><input type='range' id='optLighting' min='0' max='2' step=0.1 onInput=\"self.setLighting()\"></div>" +
    "<div>Shadows <input type='checkbox' id='optShadow'  onclick=\"self.setShadow()\"></div>" +
    '<hr>' +
    "<div class='right'><span class='button _64' onclick=\"self.toggleOptions()\">ОК</span><span class='button _64' onclick=\"self.saveOptions()\">Save</span></div>" +
    '</div>'
  this.optionsPanel.style.display = 'none'
  this.container.appendChild(this.optionsPanel)
  this.renderer = new THREE.WebGLRenderer({ antialias: true })
  this.renderer.setClearColor(params.backgroudColor || 0xffffff)
  this.renderer.setPixelRatio(window.devicePixelRatio)
  this.renderer.setSize(0, window.innerHeight - 150)
  if (undefined !== params.shadow) {
    this.renderer.shadowMap.enabled = true
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap
  }
  this.container.appendChild(this.renderer.domElement)
  this.sceneSize = params.size || 100
  this.camera = new THREE.PerspectiveCamera(
    70,
    this.container.clientWidth / this.container.clientHeight,
    params.size / 10000.0,
    2 * params.size
  )
  this.camera.position.z = this.sceneSize / 2
  this.camera.updateProjectionMatrix()
  this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement)
  this.controls.maxDistance = 0.75 * this.sceneSize
  this.controls.rotateUp(0.2)
  this.controls.rotateLeft(-0.4)
  this.controlButtons = document.createElement('div')
  this.controlButtons.className = 'glviewer_controlButtons'
  this.container.appendChild(this.controlButtons)
  this.backwardButton = document.createElement('img')
  this.backwardButton.className = 'glviewer_control'
  this.backwardButton.src = '/images/glviewer_icon_backward.png'
  this.backwardButton.onclick = function () {
    self.controls.autoRotate = -1
  }
  this.controlButtons.appendChild(this.backwardButton)
  this.pauseButton = document.createElement('img')
  this.pauseButton.className = 'glviewer_control'
  this.pauseButton.src = '/images/glviewer_icon_pause.png'
  this.pauseButton.onclick = function () {
    self.controls.autoRotate = false
  }
  this.controlButtons.appendChild(this.pauseButton)
  this.forwardButton = document.createElement('img')
  this.forwardButton.className = 'glviewer_control'
  this.forwardButton.src = '/images/glviewer_icon_forward.png'
  this.forwardButton.onclick = function () {
    self.controls.autoRotate = 1
  }
  this.controlButtons.appendChild(this.forwardButton)
  this.povButtons = document.createElement('div')
  this.povButtons.className = 'glviewer_povButtons'
  this.container.appendChild(this.povButtons)
  this.povLBButton = document.createElement('img')
  this.povLBButton.className = 'glviewer_povcontrol'
  this.povLBButton.src = '/images/glviewer_pov_lb.png'
  this.povLBButton.onclick = function () {
    self.controls.rotateLeft(
      self.controls.getAzimuthalAngle() + (3 * Math.PI) / 4
    )
    self.controls.autoRotate = 0
  }
  this.povButtons.appendChild(this.povLBButton)
  this.povBButton = document.createElement('img')
  this.povBButton.className = 'glviewer_povcontrol'
  this.povBButton.src = '/images/glviewer_pov_b.png'
  this.povBButton.onclick = function () {
    self.controls.rotateLeft(self.controls.getAzimuthalAngle() + Math.PI)
    self.controls.autoRotate = 0
  }
  this.povButtons.appendChild(this.povBButton)
  this.povRBButton = document.createElement('img')
  this.povRBButton.className = 'glviewer_povcontrol'
  this.povRBButton.src = '/images/glviewer_pov_rb.png'
  this.povRBButton.onclick = function () {
    self.controls.rotateLeft(
      self.controls.getAzimuthalAngle() - (3 * Math.PI) / 4
    )
    self.controls.autoRotate = 0
  }
  this.povButtons.appendChild(this.povRBButton)
  this.povButtons.appendChild(document.createElement('br'))
  this.povLButton = document.createElement('img')
  this.povLButton.className = 'glviewer_povcontrol'
  this.povLButton.src = '/images/glviewer_pov_l.png'
  this.povLButton.onclick = function () {
    self.controls.rotateLeft(self.controls.getAzimuthalAngle() + Math.PI / 2)
    self.controls.autoRotate = 0
  }
  this.povButtons.appendChild(this.povLButton)
  this.povTButton = document.createElement('img')
  this.povTButton.className = 'glviewer_povcontrol'
  this.povTButton.src = '/images/glviewer_pov_t.png'
  this.povTButton.onclick = function () {
    self.controls.rotateLeft(self.controls.getAzimuthalAngle())
    self.controls.rotateUp(self.controls.getPolarAngle())
    self.controls.autoRotate = 0
  }
  this.povButtons.appendChild(this.povTButton)
  this.povRButton = document.createElement('img')
  this.povRButton.className = 'glviewer_povcontrol'
  this.povRButton.src = '/images/glviewer_pov_r.png'
  this.povRButton.onclick = function () {
    self.controls.rotateLeft(self.controls.getAzimuthalAngle() - Math.PI / 2)
    self.controls.autoRotate = 0
  }
  this.povButtons.appendChild(this.povRButton)
  this.povButtons.appendChild(document.createElement('br'))
  this.povLFButton = document.createElement('img')
  this.povLFButton.className = 'glviewer_povcontrol'
  this.povLFButton.src = '/images/glviewer_pov_lf.png'
  this.povLFButton.onclick = function () {
    self.controls.rotateLeft(self.controls.getAzimuthalAngle() + Math.PI / 4)
    self.controls.autoRotate = 0
  }
  this.povButtons.appendChild(this.povLFButton)
  this.povFButton = document.createElement('img')
  this.povFButton.className = 'glviewer_povcontrol'
  this.povFButton.src = '/images/glviewer_pov_f.png'
  this.povFButton.onclick = function () {
    self.controls.rotateLeft(self.controls.getAzimuthalAngle())
    self.controls.autoRotate = 0
  }
  this.povButtons.appendChild(this.povFButton)
  this.povRFButton = document.createElement('img')
  this.povRFButton.className = 'glviewer_povcontrol'
  this.povRFButton.src = '/images/glviewer_pov_rf.png'
  this.povRFButton.onclick = function () {
    self.controls.rotateLeft(self.controls.getAzimuthalAngle() - Math.PI / 4)
    self.controls.autoRotate = 0
  }
  this.povButtons.appendChild(this.povRFButton)
  this.scene = new THREE.Scene()
  this.scene.add(this.camera)
  this.object3D = new THREE.Object3D()
  this.scene.add(self.object3D)
  this.raycaster = new THREE.Raycaster()
  if (undefined !== params.videoCapture) {
    this.capturer = new glCapturer(this, params.videoCapture)
  }
  this.textures = []
  this.materials = [
    new THREE.MeshPhongMaterial({
      name: '_default_',
      color: 0x808080,
      side: THREE.DoubleSide
    })
  ]
  this.materialDefs = [{ name: '_default', color: 0x808080 }]
  this.environment = {}
  this.render = function () {
    requestAnimationFrame(self.render)
    if (self.onAnimate) {
      self.onAnimate()
    }
    if (undefined === self.capturer || !self.capturer.captureMode) {
      self.controls.update()
    } else {
      self.capturer.update()
    }
    if (self.environment.water) {
      self.environment.water.water.material.uniforms.time.value += 1.0 / 400.0
      self.environment.water.water.render()
    }
    self.renderer.render(self.scene, self.camera)
    if (self.capturer && self.capturer.captureMode) {
      self.capturer.capture()
    }
    if (self.onRaycast) {
      self.raycast()
    }
  }
  this.activeLoads = 0
}
glViewer.prototype = {
  constructor: glViewer,
  loadModel: function (model) {
    this.busyIcon.style.display = 'block'
    if (typeof model == 'string') {
      this.LoadModelFromUrl(model)
    } else {
      this.loadModelFrom(model)
    }
  },
  reloadModel: function (model) {
    while (this.object3D.children.length) {
      this.object3D.remove(this.object3D.children[0])
    }
    this.loadModel(model)
  },
  loadModelFrom: function (model) {
    this.activeLoads += Object.keys(model).length
    for (m in model) {
      this.load(this.basePath + model[m].model, model[m].transform)
    }
  },
  loadModelFromUrl: function (url) {
    url = this.basePath + url
    var xhr = new XMLHttpRequest()
    var length = 0
    xhr.onreadystatechange = function () {
      if (xhr.readyState === xhr.DONE) {
        if (xhr.status === 200 || xhr.status === 0) {
          if (xhr.responseText) {
            var json = JSON.parse(xhr.responseText)
            self.loadModelFrom(json)
          } else {
            console.log(
              'LoadModel: ' +
                url +
                ' seems to be unreachable or the file is empty.'
            )
          }
        } else {
          console.log(
            "LoadModel: Couldn't load " + url + ' (' + xhr.status + ')'
          )
        }
      }
    }
    xhr.open('GET', url, true)
    xhr.send(null)
  },
  load: function (url, transform) {
    if (url.indexOf('.gz') === -1) {
      url = url + '.json'
      this.loadAjaxJSON(this, url, transform)
    } else {
      this.loadAjaxGZ(this, url, transform)
    }
  },
  loadAjaxGZ: function (context, url, transform) {
    var xhr = new XMLHttpRequest()
    var length = 0
    xhr.open('GET', url, true)
    xhr.timeout = 300000
    xhr.responseType = 'arraybuffer'
    xhr.onreadystatechange = function () {
      if (xhr.readyState === xhr.DONE) {
        if (xhr.status === 200 || xhr.status === 0) {
          if (xhr.response) {
            var arrayBuffer = xhr.response
            var byteArray = new Uint8Array(arrayBuffer)
            try {
              var data = pako.inflate(byteArray, { to: 'string' })
              var json = JSON.parse(data)
              context.addObject(json, transform)
            } catch (e) {}
          } else {
            console.log(
              'loadAjaxGZ: ' +
                url +
                ' seems to be unreachable or the file is empty.'
            )
          }
        } else {
          console.log(
            "loadAjaxGZ: Couldn't load " + url + ' (' + xhr.status + ')'
          )
        }
        context.ajaxRequestComplete()
      }
    }
    xhr.send(null)
  },
  loadAjaxJSON: function (context, url, transform) {
    var xhr = new XMLHttpRequest()
    var length = 0
    xhr.onreadystatechange = function () {
      if (xhr.readyState === xhr.DONE) {
        if (xhr.status === 200 || xhr.status === 0) {
          if (xhr.responseText) {
            var json = JSON.parse(xhr.responseText)
            context.addObject(json, transform)
          } else {
            console.log(
              'loadAjaxJSON: ' +
                url +
                ' seems to be unreachable or the file is empty.'
            )
          }
          context.ajaxRequestComplete()
        } else {
          console.log(
            "loadAjaxJSON: Couldn't load " + url + ' (' + xhr.status + ')'
          )
          context.ajaxRequestComplete()
        }
      }
    }
    xhr.open('GET', url, true)
    xhr.timeout = 300000
    xhr.send(null)
  },
  ajaxRequestComplete: function () {
    this.activeLoads--
    if (this.activeLoads == 0 && typeof this.onLoadComplete == 'function') {
      this.busyIcon.style.display = 'none'
      this.onLoadComplete()
    }
  },
  addObject: function (model, transform) {
    transform = transform || [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ]
    var textureLoader = new THREE.TextureLoader()
    for (var m in model.materials) {
      var material = model.materials[m]
      if (material) {
        var mjson = JSON.stringify(material)
        var material_index = -1
        for (var i = 0; i < this.materialDefs.length; i++) {
          if (JSON.stringify(this.materialDefs[i]) === mjson) {
            material_index = i
            break
          }
        }
        if (material_index == -1) {
          var mat = { name: m + '_' + this.msecStamp() }
          mat.color =
            undefined === material.diffuse ? 0x808080 : 1 * material.diffuse
          mat.specular =
            undefined === material.specular ? 0x404040 : 1 * material.specular
          mat.shininess =
            undefined === material.shininess ? 20 : 1 * material.shininess
          mat.emissive =
            undefined === material.emissive ? 0x000000 : 1 * material.emissive
          mat.emissiveIntensity =
            undefined === material.emissiveIntensity
              ? 1.0
              : 1 * material.emissiveIntensity
          mat.transparent =
            undefined === material.transparent ? false : material.transparent
          mat.opacity =
            undefined === material.opacity ? 1.0 : 1 * material.opacity
          mat.alphaTest =
            undefined === material.alphaTest ? 0.0 : 1 * material.alphaTest
          mat.depthWrite =
            undefined === material.depthWrite ? true : material.depthWrite
          mat.premultipliedAlpha =
            undefined === material.premultipliedAlpha
              ? false
              : material.premultipliedAlpha
          mat.side = THREE.DoubleSide
          if (mat.opacity < 0.999) {
            mat.transparent = true
            mat.depthWrite = false
          }
          if (undefined != material.diffuseMap) {
            var diffuseMap = material.diffuseMap
            if (typeof material.diffuseMap === 'object') {
              diffuseMap =
                material.diffuseMap[Object.keys(material.diffuseMap)[0]]
            }
            if (undefined == this.textures[diffuseMap]) {
              var map = textureLoader.load(this.basePath + diffuseMap)
              map.name = diffuseMap
              map.wrapS = THREE.RepeatWrapping
              map.wrapT = THREE.RepeatWrapping
              map.flipY = false
              this.textures[diffuseMap] = map
            }
            mat.map = this.textures[diffuseMap]
          }
          if (undefined != material.specularMap) {
            var specularMap = material.specularMap
            if (typeof material.specularMap === 'object') {
              specularMap =
                material.specularMap[Object.keys(material.specularMap)[0]]
            }
            if (undefined == this.textures[specularMap]) {
              var map = textureLoader.load(this.basePath + specularMap)
              map.name = specularMap
              map.wrapS = THREE.RepeatWrapping
              map.wrapT = THREE.RepeatWrapping
              map.flipY = false
              this.textures[specularMap] = map
            }
            mat.specularMap = this.textures[material.specularMap]
          }
          if (undefined != material.bumpMap) {
            if (undefined == this.textures[material.bumpMap]) {
              var map = textureLoader.load(this.basePath + material.bumpMap)
              map.name = material.bumpMap
              map.wrapS = THREE.RepeatWrapping
              map.wrapT = THREE.RepeatWrapping
              map.flipY = false
              this.textures[material.bumpMap] = map
            }
            mat.bumpMap = this.textures[material.bumpMap]
            mat.bumpScale = material.bumpScale || 0.025
          }
          if (undefined != material.normalMap) {
            if (undefined == this.textures[material.normalMap]) {
              var map = textureLoader.load(this.basePath + material.normalMap)
              map.name = material.normalMap
              map.wrapS = THREE.RepeatWrapping
              map.wrapT = THREE.RepeatWrapping
              map.flipY = false
              this.textures[material.normalMap] = map
            }
            mat.normalMap = this.textures[material.normalMap]
          }
          if (undefined != material.aoMap) {
            if (undefined == this.textures[material.aoMap]) {
              var map = textureLoader.load(this.basePath + material.aoMap)
              map.name = material.aoMap
              map.wrapS = THREE.RepeatWrapping
              map.wrapT = THREE.RepeatWrapping
              map.flipY = false
              this.textures[material.aoMap] = map
            }
            mat.aoMap = this.textures[material.aoMap]
          }
          if (undefined != material.envMap) {
            if (undefined == this.textures[material.envMap]) {
              var map = textureLoader.load(this.basePath + material.envMap)
              map.name = material.envMap
              map.wrapS = THREE.RepeatWrapping
              map.wrapT = THREE.RepeatWrapping
              map.flipY = false
              this.textures[material.envMap] = map
            }
            mat.envMap = this.textures[material.envMap]
          }
          if (undefined != material.alphaMap) {
            if (undefined == this.textures[material.alphaMap]) {
              var map = textureLoader.load(this.basePath + material.alphaMap)
              map.name = material.alphaMap
              map.wrapS = THREE.RepeatWrapping
              map.wrapT = THREE.RepeatWrapping
              map.flipY = false
              this.textures[material.alphaMap] = map
            }
            mat.alphaMap = this.textures[material.alphaMap]
            if (mat.transparent) {
              mat.depthWrite = false
              mat.depthTest = true
            }
          }
          if (undefined != material.metalnessMap) {
            if (undefined == this.textures[material.metalnessMap]) {
              var map = textureLoader.load(
                this.basePath + material.metalnessMap
              )
              map.name = material.metalnessMap
              map.wrapS = THREE.RepeatWrapping
              map.wrapT = THREE.RepeatWrapping
              map.flipY = false
              this.textures[material.metalnessMap] = map
            }
            mat.metalnessMap = this.textures[material.metalnessMap]
            mat.metalness = material.metalness || 1
          }
          if (undefined != material.roughnessMap) {
            if (undefined == this.textures[material.roughnessMap]) {
              var map = textureLoader.load(
                this.basePath + material.roughnessMap
              )
              map.name = material.roughnessMap
              map.wrapS = THREE.RepeatWrapping
              map.wrapT = THREE.RepeatWrapping
              map.flipY = false
              this.textures[material.roughnessMap] = map
            }
            mat.roughnessMap = this.textures[material.roughnessMap]
            mat.roughness = material.roughness || 1
          }
          if (undefined != material.emissiveMap) {
            if (undefined == this.textures[material.emissiveMap]) {
              var map = textureLoader.load(this.basePath + material.emissiveMap)
              map.name = material.emissiveMap
              map.wrapS = THREE.RepeatWrapping
              map.wrapT = THREE.RepeatWrapping
              map.flipY = false
              this.textures[material.emissiveMap] = map
            }
            mat.emissiveMap = this.textures[material.emissiveMap]
            mat.emissiveIntensity = material.emissiveIntensity
          }
          var new_material
          if (material.shader == 'pbs') {
            new_material = new THREE.MeshStandardMaterial(mat)
          } else if (material.shader == 'lambert') {
            new_material = new THREE.MeshLambertMaterial(mat)
          } else {
            new_material = new THREE.MeshPhongMaterial(mat)
          }
          new_material.mType = material.type || ''
          new_material.mThickness = material.thickness || 0
          this.materialDefs.push(material)
          this.materials.push(new_material)
        }
      }
    }
    var model_material = new THREE.MeshFaceMaterial(this.materials)
    for (var o in model.objects) {
      var object = model.objects[o]
      if (object.vertices) {
        var geometry = new THREE.Geometry()
        geometry.faceVertexUvs = []
        geometry.faceVertexUvs[0] = []
        for (var i = 0; i < object.vertices.length; i = i + 3) {
          geometry.vertices.push(
            new THREE.Vector3(
              object.vertices[i],
              object.vertices[i + 1],
              object.vertices[i + 2]
            )
          )
        }
        for (var g in object.groups) {
          var group = object.groups[g]
          var mjson = JSON.stringify(model.materials[group.material])
          var material_index = 0
          for (var i = 0; i < this.materialDefs.length; i++) {
            if (JSON.stringify(this.materialDefs[i]) === mjson) {
              material_index = i
              break
            }
          }
          for (var i = 0; i < group.indices.length; i = i + 3) {
            var idx0 = group.indices[i]
            var idx1 = group.indices[i + 1]
            var idx2 = group.indices[i + 2]
            var f = new THREE.Face3(idx0, idx1, idx2)
            f.materialIndex = material_index
            geometry.faces.push(f)
          }
          if (undefined != object.uvs) {
            for (var i = 0; i < group.indices.length; i = i + 3) {
              var idx0 = group.indices[i]
              var idx1 = group.indices[i + 1]
              var idx2 = group.indices[i + 2]
              geometry.faceVertexUvs[0].push([
                new THREE.Vector2(
                  object.uvs[idx0 * 2],
                  object.uvs[idx0 * 2 + 1]
                ),
                new THREE.Vector2(
                  object.uvs[idx1 * 2],
                  object.uvs[idx1 * 2 + 1]
                ),
                new THREE.Vector2(
                  object.uvs[idx2 * 2],
                  object.uvs[idx2 * 2 + 1]
                )
              ])
            }
          } else {
            for (var i = 0; i < group.indices.length; i = i + 3) {
              geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, 0),
                new THREE.Vector2(0, 1),
                new THREE.Vector2(1, 0)
              ])
            }
          }
        }
        geometry.faceVertexUvs[1] = geometry.faceVertexUvs[0]
        geometry.applyMatrix(
          new THREE.Matrix4().set(
            transform[0][0],
            transform[1][0],
            transform[2][0],
            transform[3][0],
            transform[0][1],
            transform[1][1],
            transform[2][1],
            transform[3][1],
            transform[0][2],
            transform[1][2],
            transform[2][2],
            transform[3][2],
            transform[0][3],
            transform[1][3],
            transform[2][3],
            transform[3][3]
          )
        )
        geometry.computeFaceNormals()
        geometry.computeVertexNormals()
        var mesh = new THREE.Mesh(geometry, model_material)
        mesh.name = o
        mesh.castShadow = true
        mesh.receiveShadow = true
        this.object3D.add(mesh)
      }
    }
  },
  changeMaterialSet: function (mset) {
    var textureLoader = new THREE.TextureLoader()
    for (var m in this.materials) {
      var material = this.materialDefs[m]
      if (undefined != material.diffuseMap) {
        var diffuseMap = material.diffuseMap
        if (typeof material.diffuseMap === 'object') {
          diffuseMap = material.diffuseMap[mset] || material.diffuseMap.default
        }
        if (undefined == this.textures[diffuseMap]) {
          var map = textureLoader.load(this.basePath + diffuseMap)
          map.name = diffuseMap
          map.wrapS = THREE.RepeatWrapping
          map.wrapT = THREE.RepeatWrapping
          map.flipY = false
          this.textures[diffuseMap] = map
        }
        this.materials[m].map = this.textures[diffuseMap]
      }
    }
    for (var m in this.materials) {
      var material = this.materialDefs[m]
      if (undefined != material.specularMap) {
        var specularMap = material.specularMap
        if (typeof material.specularMap === 'object') {
          specularMap = material.specularMap[mset]
        }
        if (undefined == this.textures[specularMap]) {
          var map = textureLoader.load(this.basePath + specularMap)
          map.name = specularMap
          map.wrapS = THREE.RepeatWrapping
          map.wrapT = THREE.RepeatWrapping
          map.flipY = false
          this.textures[specularMap] = map
        }
        this.materials[m].specularMap = this.textures[specularMap]
      }
    }
  },
  resize: function () {
    var fullScreen = this.container.style.position === 'absolute'
    var width = this.container.clientWidth
    var height = window.innerHeight - 150 * !fullScreen
    this.container.clientHeight = height
    this.camera.aspect = width / height
    this.camera.updateProjectionMatrix()
    this.renderer.setSize(width, height)
    return
  },
  centerObject: function (vertical) {
    vertical = vertical || false
    var min = new THREE.Vector3(
      Number.MAX_VALUE,
      Number.MAX_VALUE,
      Number.MAX_VALUE
    )
    var max = new THREE.Vector3(
      -Number.MAX_VALUE,
      -Number.MAX_VALUE,
      -Number.MAX_VALUE
    )
    for (object in this.object3D.children) {
      this.object3D.children[object].geometry.computeBoundingBox()
      min.x = Math.min(
        min.x,
        this.object3D.children[object].geometry.boundingBox.min.x
      )
      min.y = Math.min(
        min.y,
        this.object3D.children[object].geometry.boundingBox.min.y
      )
      min.z = Math.min(
        min.z,
        this.object3D.children[object].geometry.boundingBox.min.z
      )
      max.x = Math.max(
        max.x,
        this.object3D.children[object].geometry.boundingBox.max.x
      )
      max.y = Math.max(
        max.y,
        this.object3D.children[object].geometry.boundingBox.max.y
      )
      max.z = Math.max(
        max.z,
        this.object3D.children[object].geometry.boundingBox.max.z
      )
    }
    var pos = new THREE.Vector3(max.x + min.x, max.y + min.y, max.z + min.z)
    pos = pos.divideScalar(2)
    pos.negate()
    var translation
    if (vertical === false) {
      translation = new THREE.Matrix4().makeTranslation(pos.x, 0, pos.z)
    } else if (vertical === true) {
      translation = new THREE.Matrix4().makeTranslation(pos.x, pos.y, pos.z)
    } else if (vertical === 'ground') {
      translation = new THREE.Matrix4().makeTranslation(
        pos.x,
        -min.y + 0.001,
        pos.z
      )
      this.camera.position.y -= pos.y
      this.camera.lookAt(new THREE.Vector3(0, -pos.y, 0))
    }
    for (object in this.object3D.children) {
      this.object3D.children[object].geometry.applyMatrix(translation)
    }
    var aspect = this.container.clientWidth / this.container.clientHeight
    this.camera.position.z =
      1.5 *
      Math.max(
        max.x - min.x,
        (max.y - min.y) * aspect,
        (max.z - min.z) / aspect
      )
    var r = min.distanceTo(max)
    if (undefined === this.params.size) {
      this.camera.near = 0.0001 * r
      this.camera.far = 10 * r
      this.camera.updateProjectionMatrix()
    }
    this.controls.maxDistance = 5 * r
    return {
      width: max.x - min.x,
      height: max.y - min.y,
      length: max.z - min.z,
      radius: r / 2
    }
  },
  addButtons: function (params) {
    if (params.info) {
      this.infoButton = document.createElement('img')
      this.infoButton.src = params.info.icon
      this.infoButton.title = params.info.name
      self = this
      this.infoButton.onclick = function () {
        self.toggleInfo()
      }
      this.controlPanel.appendChild(this.infoButton)
      this.infoPanel.innerHTML = params.info.html
    }
    if (params.camouflage) {
      this.camoButton = document.createElement('img')
      this.camoButton.src = params.camouflage.icon
      this.camoButton.title = params.camouflage.name
      self = this
      this.camoButton.onclick = function () {
        var fragment = document.createDocumentFragment()
        var div = document.createElement('div')
        for (var c in params.camouflage.list) {
          var camo = params.camouflage.list[c]
          var img = document.createElement('img')
          img.className = 'button glviewer_camo_button'
          img.src = camo.icon
          img.title = camo.title
          img.name = c
          img.onclick = function () {
            self.changeMaterialSet(this.name)
          }
          div.appendChild(img)
        }
        fragment.appendChild(div)
        ELEMENTS.openDialog({
          id: 'Camouflage',
          position: { x: self.mouse.x + 16, y: self.mouse.y + 16 },
          caption: self.camoButton.title,
          content: fragment
        })
      }
      this.controlPanel.appendChild(this.camoButton)
    }
    if (params.environment) {
      this.envButton = document.createElement('img')
      this.envButton.src = params.environment.icon
      this.envButton.title = params.environment.name
      self = this
      this.envButton.onclick = function () {
        self.toggleEnvironment()
      }
      this.controlPanel.appendChild(this.envButton)
    }
    if (params.save) {
      params.save.enable = params.save.enable || false
      this.saveButton = document.createElement('img')
      this.saveButton.src = params.save.icon
      this.saveButton.title = params.save.name
      self = this
      if (params.save.enable) {
        this.saveButton.onclick = function () {
          self.saveModel(params.save.filename)
        }
      } else {
        this.saveButton.onclick = function () {
          self.requestRegister()
        }
      }
      this.controlPanel.appendChild(this.saveButton)
    }
    if (params.options) {
      this.optionsButton = document.createElement('img')
      this.optionsButton.src = '/images/glviewer_icon_options.png'
      this.optionsButton.title = ''
      document.getElementById('optAmbient').value =
        params.options.ambient || 1.0
      this.setAmbient()
      document.getElementById('optLighting').value =
        params.options.lighting || 1.0
      this.setLighting()
      document.getElementById('optShadow').checked =
        undefined === params.options.shadow ? true : params.options.shadow
      this.setShadow()
      self = this
      this.optionsButton.onclick = function () {
        self.toggleOptions(params.options)
      }
      this.controlPanel.appendChild(this.optionsButton)
    }
  },
  addButton: function (params) {
    var button = document.createElement('img')
    button.src = params.icon
    button.title = params.name
    self = this
    button.onclick = params.onclick
    this.controlPanel.appendChild(button)
    return button
  },
  saveModel: function (filename) {
    var fragment = document.createDocumentFragment()
    var spacer = document.createElement('span')
    spacer.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'
    fragment.appendChild(spacer)
    var saveObj = document.createElement('img')
    saveObj.className = 'button'
    saveObj.src = '/images/glviewer_obj_format.png'
    saveObj.alt = 'OBJ'
    saveObj.onclick = function () {
      self.saveModelAsOBJ(filename)
      ELEMENTS.close('SaveAs')
    }
    fragment.appendChild(saveObj)
    var spacer = document.createElement('span')
    spacer.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'
    fragment.appendChild(spacer)
    var saveStl = document.createElement('img')
    saveStl.className = 'button'
    saveStl.src = '/images/glviewer_stl_format.png'
    saveStl.alt = 'STL'
    saveStl.onclick = function () {
      self.saveModelAsSTL(filename)
      ELEMENTS.close('SaveAs')
    }
    fragment.appendChild(saveStl)
    ELEMENTS.openModalDialog({
      id: 'SaveAs',
      caption: self.saveButton.title,
      content: fragment
    })
  },
  saveModelAsOBJ: function (filename) {
    var asciiname = transliterate(removeDiacritics(filename))
    asciiname = asciiname.replace(/[\s\\\/]/gi, '_')
    var obj = 'mtllib ' + asciiname + '.mtl\n\n'
    var vertices = ''
    var faces = ''
    var mtllib = ''
    var vbase = 1
    var names = []
    for (var m in this.object3D.children) {
      var mesh = this.object3D.children[m]
      if (mesh.geometry.vertices.length) {
        var name = mesh.name
        var nIndex = ''
        while (names.indexOf(name + nIndex) != -1) {
          nIndex++
        }
        name = name + nIndex
        names.push(name)
        faces = faces + 'g ' + name + '\n'
        for (var v in mesh.geometry.vertices) {
          var vertice = mesh.geometry.vertices[v]
          vertices =
            vertices +
            'v ' +
            vertice.x.toFixed(5) +
            ' ' +
            vertice.y.toFixed(5) +
            ' ' +
            vertice.z.toFixed(5) +
            '\n'
        }
      }
      vertices = vertices + '\n'
      var uvs = []
      if (mesh.geometry.faces.length) {
        var matIndex = -1
        for (var f in mesh.geometry.faces) {
          var face = mesh.geometry.faces[f]
          if (face.materialIndex != matIndex) {
            matIndex = face.materialIndex
            faces = faces + 'usemtl ' + this.materials[matIndex].name + '\n'
          }
          uvs[face.a] = mesh.geometry.faceVertexUvs[0][f][0]
          uvs[face.b] = mesh.geometry.faceVertexUvs[0][f][1]
          uvs[face.c] = mesh.geometry.faceVertexUvs[0][f][2]
          var a = face.a + vbase
          var b = face.b + vbase
          var c = face.c + vbase
          faces =
            faces +
            'f ' +
            a +
            '/' +
            a +
            ' ' +
            b +
            '/' +
            b +
            ' ' +
            c +
            '/' +
            c +
            '\n'
        }
        vbase = vbase + mesh.geometry.vertices.length
        faces = faces + '\n'
      }
      for (var i = 0; i < mesh.geometry.vertices.length; i++) {
        if (undefined === uvs[i]) {
          vertices = vertices + 'vt 0 0\n'
        } else {
          vertices =
            vertices +
            'vt ' +
            uvs[i].x.toFixed(4) +
            ' ' +
            (-uvs[i].y).toFixed(4) +
            '\n'
        }
      }
    }
    var zip = new JSZip()
    zip.file(asciiname + '.obj', obj + vertices + faces)
    var ztextures = zip.folder('textures')
    for (var m in this.materials) {
      var material = this.materials[m]
      mtllib = mtllib + 'newmtl ' + material.name + '\n'
      mtllib =
        mtllib +
        'Kd ' +
        material.color.r.toFixed(3) +
        ' ' +
        material.color.g.toFixed(3) +
        ' ' +
        material.color.b.toFixed(3) +
        ' ' +
        '\n'
      if (undefined === material.specular) {
        mtllib = mtllib + 'Ks 0.25 0.25 0.25 \n'
      } else {
        mtllib =
          mtllib +
          'Ks ' +
          material.specular.r.toFixed(3) +
          ' ' +
          material.specular.g.toFixed(3) +
          ' ' +
          material.specular.b.toFixed(3) +
          ' ' +
          '\n'
      }
      if (undefined === material.specular) {
        mtllib = mtllib + 'Ns 30\n'
      } else {
        mtllib = mtllib + 'Ns ' + material.shininess + '\n'
      }
      if (material.map) {
        var texfile = fileName(material.map.name)
        mtllib = mtllib + 'map_Kd textures/' + texfile + '\n'
        var xhr = new XMLHttpRequest()
        xhr.open('GET', this.basePath + material.map.name, false)
        xhr.overrideMimeType('text/plain; charset=x-user-defined')
        xhr.send(null)
        if (xhr.status === 200) {
          ztextures.file(texfile, stringToArrayBuffer(xhr.responseText))
        }
      }
      if (material.specularMap) {
        var texfile = fileName(material.specularMap.name)
        mtllib = mtllib + 'map_Ks textures/' + texfile + '\n'
        var xhr = new XMLHttpRequest()
        xhr.open('GET', this.basePath + material.specularMap.name, false)
        xhr.overrideMimeType('text/plain; charset=x-user-defined')
        xhr.send(null)
        if (xhr.status === 200) {
          ztextures.file(texfile, stringToArrayBuffer(xhr.responseText))
        }
      }
      if (material.normalMap) {
        var texfile = fileName(material.normalMap.name)
        mtllib = mtllib + 'map_bump textures/' + texfile + '\n'
        var xhr = new XMLHttpRequest()
        xhr.open('GET', this.basePath + material.normalMap.name, false)
        xhr.overrideMimeType('text/plain; charset=x-user-defined')
        xhr.send(null)
        if (xhr.status === 200) {
          ztextures.file(texfile, stringToArrayBuffer(xhr.responseText))
        }
      }
      if (material.aoMap) {
        var texfile = fileName(material.aoMap.name)
        mtllib = mtllib + 'map_Ao textures/' + texfile + '\n'
        var xhr = new XMLHttpRequest()
        xhr.open('GET', this.basePath + material.aoMap.name, false)
        xhr.overrideMimeType('text/plain; charset=x-user-defined')
        xhr.send(null)
        if (xhr.status === 200) {
          ztextures.file(texfile, stringToArrayBuffer(xhr.responseText))
        }
      }
      if (material.emissiveMap) {
        var texfile = fileName(material.emissiveMap.name)
        mtllib = mtllib + 'map_emissive textures/' + texfile + '\n'
        var xhr = new XMLHttpRequest()
        xhr.open('GET', this.basePath + material.emissiveMap.name, false)
        xhr.overrideMimeType('text/plain; charset=x-user-defined')
        xhr.send(null)
        if (xhr.status === 200) {
          ztextures.file(texfile, stringToArrayBuffer(xhr.responseText))
        }
      }
      if (material.alphaMap) {
        var texfile = fileName(material.alphaMap.name)
        mtllib = mtllib + 'map_d textures/' + texfile + '\n'
        var xhr = new XMLHttpRequest()
        xhr.open('GET', this.basePath + material.alphaMap.name, false)
        xhr.overrideMimeType('text/plain; charset=x-user-defined')
        xhr.send(null)
        if (xhr.status === 200) {
          ztextures.file(texfile, stringToArrayBuffer(xhr.responseText))
        }
      }
      if (material.metalnessMap) {
        var texfile = fileName(material.metalnessMap.name)
        mtllib = mtllib + 'map_metalness textures/' + texfile + '\n'
        var xhr = new XMLHttpRequest()
        xhr.open('GET', this.basePath + material.metalnessMap.name, false)
        xhr.overrideMimeType('text/plain; charset=x-user-defined')
        xhr.send(null)
        if (xhr.status === 200) {
          ztextures.file(texfile, stringToArrayBuffer(xhr.responseText))
        }
      }
      if (material.roughnessMap) {
        var texfile = fileName(material.roughnessMap.name)
        mtllib = mtllib + 'map_roughness textures/' + texfile + '\n'
        var xhr = new XMLHttpRequest()
        xhr.open('GET', this.basePath + material.roughnessMap.name, false)
        xhr.overrideMimeType('text/plain; charset=x-user-defined')
        xhr.send(null)
        if (xhr.status === 200) {
          ztextures.file(texfile, stringToArrayBuffer(xhr.responseText))
        }
      }
      mtllib = mtllib + '\n'
    }
    zip.file(asciiname + '.mtl', mtllib)
    var content = zip.generate({ type: 'blob', compression: 'deflate' })
    saveAs(content, asciiname + '.zip')
  },
  saveModelAsSTL: function (filename) {
    var asciiname = transliterate(removeDiacritics(filename))
    asciiname = asciiname.replace(/\s/gi, '_')
    var stl = 'solid ' + asciiname + '\n'
    for (var m in this.object3D.children) {
      var mesh = this.object3D.children[m]
      if (mesh.geometry.faces.length) {
        var matIndex = -1
        for (var f in mesh.geometry.faces) {
          var face = mesh.geometry.faces[f]
          stl += 'facet normal 0 0 0\n'
          stl += 'outer loop\n'
          var vertice = mesh.geometry.vertices[face.a]
          stl +=
            'vertex ' +
            vertice.x.toFixed(5) +
            ' ' +
            -vertice.z.toFixed(5) +
            ' ' +
            vertice.y.toFixed(5) +
            '\n'
          var vertice = mesh.geometry.vertices[face.b]
          stl +=
            'vertex ' +
            vertice.x.toFixed(5) +
            ' ' +
            -vertice.z.toFixed(5) +
            ' ' +
            vertice.y.toFixed(5) +
            '\n'
          var vertice = mesh.geometry.vertices[face.c]
          stl +=
            'vertex ' +
            vertice.x.toFixed(5) +
            ' ' +
            -vertice.z.toFixed(5) +
            ' ' +
            vertice.y.toFixed(5) +
            '\n'
          stl += 'endloop\n'
          stl += 'endfacet\n'
        }
      }
    }
    stl += 'endsolid ' + asciiname
    var zip = new JSZip()
    zip.file(asciiname + '.stl', stl)
    var content = zip.generate({ type: 'blob', compression: 'deflate' })
    saveAs(content, asciiname + '.zip')
  },
  toggleOptions: function (options) {
    var hidden = this.optionsPanel.style.display === 'none'
    if (hidden) {
      this.optionsPanel.style.display = 'inline-block'
      this.optionsButton.style.opacity = 0.7
    } else {
      this.optionsPanel.style.display = 'none'
      this.optionsButton.style.opacity = ''
    }
  },
  setInfo: function (info) {
    this.infoPanel.innerHTML = info
    if (this.infoPanel.style.display === 'none') {
      this.infoPanel.style.display = 'inline-block'
      this.infoButton.style.opacity = 0.7
    }
  },
  toggleInfo: function () {
    var hidden = this.infoPanel.style.display === 'none'
    if (hidden) {
      this.infoPanel.style.display = 'inline-block'
      this.infoButton.style.opacity = 0.7
    } else {
      this.infoPanel.style.display = 'none'
      this.infoButton.style.opacity = ''
    }
  },
  setEnvironment: function (params) {
    if (params.cubemap) {
      this.addCubemap(params.cubemap)
    }
    if (params.sky) {
      this.addSkydome(params.sky)
    }
    if (params.water) {
      this.addWater(params.water)
      this.controls.maxPolarAngle = Math.PI / 2.02
    }
    if (params.waterline) {
      this.addWaterline(params.waterline)
    }
    if (params.pavilion) {
      this.addPavilion(params.pavilion)
    }
    this.environment.visible = true
  },
  toggleEnvironment: function () {
    this.environment.visible = !this.environment.visible
    if (this.environment.cubemap) {
      this.environment.cubemap.visible = this.environment.visible
    }
    if (this.environment.sky) {
      this.environment.sky.visible = this.environment.visible
    }
    if (this.environment.pavilion) {
      this.environment.pavilion.visible = this.environment.visible
    }
    if (this.environment.water) {
      this.environment.water.mirror.visible = this.environment.visible
      if (this.environment.visible) {
        this.controls.maxPolarAngle = Math.PI / 2.05
      } else {
        this.controls.maxPolarAngle = Math.PI
      }
    }
    if (this.environment.waterline) {
      this.environment.waterline.visible = this.environment.visible
    }
  },
  addCubemap: function (params) {
    size = params.radius || 1.1 * this.sceneSize
    var skybox = params.texture
    var urls = [
      skybox + '/1.jpg',
      skybox + '/2.jpg',
      skybox + '/3.jpg',
      skybox + '/4.jpg',
      skybox + '/5.jpg',
      skybox + '/6.jpg'
    ]
    var cubemap = THREE.ImageUtils.loadTextureCube(urls)
    cubemap.format = THREE.RGBFormat
    var shader = THREE.ShaderLib['cube']
    shader.uniforms['tCube'].value = cubemap
    var skyBoxMaterial = new THREE.ShaderMaterial({
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader,
      uniforms: shader.uniforms,
      depthWrite: false,
      side: THREE.BackSide
    })
    this.environment.cubemap = new THREE.Mesh(
      new THREE.CubeGeometry(size, size, size),
      skyBoxMaterial
    )
    this.scene.add(this.environment.cubemap)
  },
  addPavilion: function (params) {
    params.size = params.radius || 0.9 * this.sceneSize
    params.type = params.type || 'ground'
    var material = new THREE.MeshLambertMaterial({
      dithering: true,
      flatShading: true,
      color: params.color || 0x404040,
      side: THREE.DoubleSide
    })
    this.environment.pavilion = {}
    var geometry = new THREE.SphereGeometry(1, 32, 32)
    if (params.type === 'ground') {
      for (var v in geometry.vertices) {
        var vertice = geometry.vertices[v]
        if (vertice.y < 0) {
          vertice.y = 0
        }
      }
    }
    geometry.scale(params.size, params.size, params.size)
    geometry.computeFaceNormals()
    geometry.computeVertexNormals()
    this.environment.pavilion = new THREE.Mesh(geometry, material)
    this.environment.pavilion.receiveShadow = true
    this.scene.add(this.environment.pavilion)
  },
  addPavilionOld: function (params) {
    size = params.radius || 0.9 * this.sceneSize
    var material = new THREE.MeshPhongMaterial({
      color: params.color || 0x404040,
      side: THREE.DoubleSide,
      shininess: 50
    })
    this.environment.pavilion = {}
    var geometry
    if (undefined === params.sphere) {
      geometry = new THREE.SphereGeometry(
        size,
        60,
        40,
        0,
        2 * Math.PI,
        0,
        Math.PI / 1.9
      )
    } else {
      geometry = new THREE.SphereGeometry(
        size,
        60,
        40,
        0,
        2 * Math.PI,
        0,
        Math.PI
      )
    }
    this.environment.pavilion.dome = new THREE.Mesh(geometry, material)
    if (undefined === params.sphere) {
      var material = new THREE.MeshPhongMaterial({
        color: params.groundColor || params.color || 0x404040,
        side: THREE.DoubleSide,
        shininess: 50
      })
      var geometry = new THREE.BoxGeometry(2 * size, 0.2, 2 * size)
      this.environment.pavilion.ground = new THREE.Mesh(geometry, material)
      this.environment.pavilion.ground.dropShadow = false
      this.environment.pavilion.ground.receiveShadow = true
      this.environment.pavilion.ground.translateY(-0.1)
      this.scene.add(this.environment.pavilion.ground)
    }
    this.scene.add(this.environment.pavilion.dome)
  },
  addSkydome: function (params) {
    size = params.radius || 0.9 * this.sceneSize
    var textureLoader = new THREE.TextureLoader()
    if (undefined == this.environment.sky) {
      var geometry = new THREE.SphereGeometry(
        size,
        60,
        40,
        0,
        2 * Math.PI,
        0,
        Math.PI / 1.9
      )
      var uniforms = {
        texture: {
          type: 't',
          value: textureLoader.load(
            params.texture,
            THREE.SphericalReflectionMapping
          )
        }
      }
      var vertexShader = [
        'varying vec2 vUV;',
        'void main() {',
        'vUV = uv;',
        'vec4 pos = vec4(position, 1.0);',
        'gl_Position = projectionMatrix * modelViewMatrix * pos;',
        '}'
      ].join('\n')
      var fragmentShader = [
        'uniform sampler2D texture;',
        'varying vec2 vUV;',
        'void main() {',
        'vec4 sample = texture2D(texture, vUV);',
        'gl_FragColor = vec4(sample.xyz, sample.w);',
        '}'
      ].join('\n')
      var material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        side: THREE.BackSide
      })
      this.environment.sky = new THREE.Mesh(geometry, material)
      this.scene.add(this.environment.sky)
    }
  },
  addWater: function (params) {
    if (undefined == this.water) {
      this.environment.water = {}
      var textureLoader = new THREE.TextureLoader()
      var waterNormals = new textureLoader.load(params.texture)
      waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping
      var sunDirection =
        undefined !== this.directionalLights
          ? this.directionalLights[0].position.clone().normalize()
          : this.pointLights[0].position.clone().normalize()
      this.environment.water.water = new THREE.Water(
        this.renderer,
        this.camera,
        this.scene,
        {
          textureWidth: params.textureWidth || 512,
          textureHeight: params.textureHeight || 512,
          waterNormals: waterNormals,
          alpha: params.alpha || 1,
          sunDirection: sunDirection,
          sunColor: params.sunColor || 0xffffff,
          waterColor: params.waterColor || 0x001e0f,
          distortionScale: params.distortionScale || 50.0
        }
      )
      this.environment.water.mirror = new THREE.Mesh(
        new THREE.CircleBufferGeometry(0.85 * this.sceneSize, 24),
        this.environment.water.water.material
      )
      this.environment.water.mirror.add(this.environment.water.water)
      this.environment.water.mirror.rotation.x = -Math.PI * 0.5
      this.scene.add(this.environment.water.mirror)
    }
  },
  addWaterline: function (params) {
    if (undefined == this.waterline) {
      var material = new THREE.MeshBasicMaterial({
        color: params.color,
        opacity: params.opacity,
        transparent: true,
        side: THREE.DoubleSide
      })
      this.environment.waterline = new THREE.Mesh(
        new THREE.CircleBufferGeometry(this.sceneSize / 2, 36),
        material
      )
      this.environment.waterline.rotation.x = -Math.PI * 0.5
      this.environment.waterline.geometry.scale(0.2, 0.45, 1)
      this.scene.add(this.environment.waterline)
    }
  },
  fullScreen: function () {
    var state = this.container.style.position === 'absolute'
    if (state) {
      this.container.style.position = ''
    } else {
      this.container.style.position = 'absolute'
      this.container.style.top = 0
      this.container.style.left = 0
      this.container.style.width = '100%'
    }
    self.resize()
  },
  setLights: function (lights) {
    if (undefined !== this.ambientLight) {
      this.scene.remove(this.ambientLight)
      delete this.ambientLight
    }
    if (undefined !== this.hemisphereLight) {
      this.scene.remove(this.hemisphereLight)
      delete this.hemisphereLight
    }
    if (undefined !== this.directionalLights) {
      for (var i = 0; i < this.directionalLights; i++) {
        this.scene.remove(this.directionalLights[i])
        delete this.directionalLights[i]
      }
      this.directionalLights.length = 0
    }
    if (undefined !== this.pointLights) {
      for (var i = 0; i < this.pointLights; i++) {
        this.scene.remove(this.pointLights[i])
        delete this.pointLights[i]
      }
      this.pointLights.length = 0
    }
    if (undefined !== this.spotLights) {
      for (var i = 0; i < this.spotLights; i++) {
        this.scene.remove(this.spotLights[i])
        delete this.spotLights[i]
      }
      this.spotLights.length = 0
    }
    if (undefined !== lights.ambient) {
      this.ambientLight = new THREE.AmbientLight(
        lights.ambient.color,
        lights.ambient.intensity || 1
      )
      this.ambientLight.intensityBase = this.ambientLight.intensity
      this.scene.add(this.ambientLight)
    }
    if (undefined !== lights.hemisphere) {
      this.hemisphereLight = new THREE.HemisphereLight(
        lights.hemisphere.skyColor,
        lights.hemisphere.groundColor,
        lights.hemisphere.intensity
      )
      this.scene.add(this.hemisphereLight)
    }
    if (undefined !== lights.directional) {
      this.directionalLights = []
      for (var i = 0; i < lights.directional.length; i++) {
        this.directionalLights[i] = new THREE.DirectionalLight(
          lights.directional[i].color,
          lights.directional[i].intensity
        )
        this.directionalLights[i].position.set(
          lights.directional[i].position[0],
          lights.directional[i].position[1],
          lights.directional[i].position[2]
        )
        this.directionalLights[i].target.position.set(0, 0, 0)
        this.scene.add(this.directionalLights[i])
      }
      if (undefined !== this.params.shadow) {
        this.directionalLights[0].castShadow = true
        this.directionalLights[0].shadow.mapSize.width =
          this.params.shadow.mapWidth || 512
        this.directionalLights[0].shadow.mapSize.height =
          this.params.shadow.mapHeight || 512
        this.directionalLights[0].shadow.camera.near =
          this.params.shadow.cameraNear || 0.05
        this.directionalLights[0].shadow.camera.far =
          this.params.shadow.cameraFar || 500
        this.directionalLights[0].shadow.radius =
          this.params.shadow.radius || 1.25
        this.directionalLights[0].shadow.bias = this.params.shadow.bias || 0
      }
    }
    if (undefined !== lights.point) {
      this.pointLights = []
      for (var i = 0; i < lights.point.length; i++) {
        this.pointLights[i] = new THREE.PointLight(
          lights.point[i].color,
          lights.point[i].intensity,
          lights.point[i].distance || 0.0,
          lights.point[i].decay || 2
        )
        this.pointLights[i].position.set(
          lights.point[i].position[0],
          lights.point[i].position[1],
          lights.point[i].position[2]
        )
        this.pointLights[i].intensityBase = this.pointLights[i].intensity
        this.scene.add(this.pointLights[i])
      }
      if (undefined !== this.params.shadow) {
        this.pointLights[0].castShadow = true
        this.pointLights[0].shadow.mapSize.width =
          this.params.shadow.mapWidth || 512
        this.pointLights[0].shadow.mapSize.height =
          this.params.shadow.mapHeight || 512
        this.pointLights[0].shadow.camera.near =
          this.params.shadow.cameraNear || 0.05
        this.pointLights[0].shadow.camera.far =
          this.params.shadow.cameraFar || 500
        this.pointLights[0].shadow.radius = this.params.shadow.radius || 1.25
        this.pointLights[0].shadow.bias = this.params.shadow.bias || 0
      }
    }
    if (undefined !== lights.spot) {
      this.spotLights = []
      for (var i = 0; i < lights.spot.length; i++) {
        this.spotLights[i] = new THREE.SpotLight(
          lights.spot[i].color,
          lights.spot[i].intensity || 1,
          lights.spot[i].distance || 0.0,
          lights.spot[i].angle || Math.PI / 2,
          lights.spot[i].penumbra || 0,
          lights.spot[i].decay || 2
        )
        this.spotLights[i].position.set(
          lights.spot[i].position[0],
          lights.spot[i].position[1],
          lights.spot[i].position[2]
        )
        if (undefined !== lights.spot[i].target) {
          this.spotLights[i].target.position.set(
            lights.spot[i].target[0],
            lights.spot[i].target[1],
            lights.spot[i].target[2]
          )
        }
        this.spotLights[i].target.updateMatrixWorld()
        if (lights.spot[i].shadow && undefined !== this.params.shadow) {
          this.spotLights[i].castShadow = true
          this.spotLights[i].shadow.mapSize.width =
            this.params.shadow.mapWidth || 512
          this.spotLights[i].shadow.mapSize.height =
            this.params.shadow.mapHeight || 512
          this.spotLights[i].shadow.camera.near =
            this.params.shadow.cameraNear || 0.05
          this.spotLights[i].shadow.camera.far =
            this.params.shadow.cameraFar || 500
          this.spotLights[i].shadow.radius = this.params.shadow.radius || 1.25
          this.spotLights[i].shadow.bias = this.params.shadow.bias || 0
        }
        this.scene.add(this.spotLights[i])
      }
    }
  },
  raycast: function () {
    var br = self.container.getBoundingClientRect()
    var x = ((self.mouse.x - br.left) / self.container.clientWidth) * 2 - 1
    var y = -((self.mouse.y - br.top) / self.container.clientHeight) * 2 + 1
    var vector = new THREE.Vector3(x, y, 1)
    vector.unproject(self.camera)
    vector = vector.sub(self.camera.position).normalize()
    self.raycaster.set(self.camera.position, vector)
    var intersects = self.raycaster.intersectObjects(self.object3D.children)
    self.onRaycast(vector, intersects)
  },
  mouseMove: function (event) {
    if (event.clientX) {
      self.mouse.x = event.clientX
      self.mouse.y = event.clientY
    }
  },
  msecStamp: function () {
    var ti = Date.now()
    return ti - 1000 * Math.floor(ti / 1000)
  },
  setAmbient: function () {
    value = document.getElementById('optAmbient').value
    if (undefined !== this.ambientLight) {
      this.ambientLight.intensity = this.ambientLight.intensityBase * value
    }
    return
  },
  setLighting: function () {
    value = document.getElementById('optLighting').value
    if (undefined !== this.pointLights) {
      this.pointLights[0].intensity = this.pointLights[0].intensityBase * value
    }
    return
  },
  setShadow: function () {
    value = document.getElementById('optShadow').checked
    if (undefined !== this.params.shadow) {
      this.renderer.shadowMap.enabled = value
      this.renderer.shadowMap.needsUpdate = true
      for (var m in this.materials) {
        this.materials[m].needsUpdate = true
      }
      if (this.environment && this.environment.pavilion) {
        this.environment.pavilion.material.needsUpdate = true
      }
    }
    return
  },
  saveOptions: function () {
    var ambient = document.getElementById('optAmbient').value
    var lighting = document.getElementById('optLighting').value
    var shadow = document.getElementById('optShadow').checked
    ELEMENTS.sendHttpRequest({
      url: '/friends/options.php',
      request:
        'path=' +
        encodeURIComponent(window.location.pathname) +
        '&ambient=' +
        ambient +
        '&lighting=' +
        lighting +
        '&shadow=' +
        shadow,
      callback: function (t) {}
    })
    this.toggleOptions()
    return
  },
  requestRegister: function () {
    var id = 'LoginDialog'
    request = 'login=needRegister'
    loadModuleModal(id, 'Войти на сайт', request)
  }
}
function stringToArrayBuffer (str) {
  var buf = new ArrayBuffer(str.length)
  var bufView = new Uint8Array(buf)
  for (var i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i) & 0xff
  }
  return buf
}
function fileName (fullPath) {
  return ('' + fullPath).replace(/^.*[\\\/]/, '')
}
function print_r (arr, level) {
  var print_red_text = ''
  if (!level) level = 0
  var level_padding = ''
  for (var j = 0; j < level + 1; j++) level_padding += '    '
  if (typeof arr == 'object') {
    for (var item in arr) {
      var value = arr[item]
      if (typeof value == 'object') {
        print_red_text += level_padding + "'" + item + "' :\n"
        print_red_text += print_r(value, level + 1)
      } else
        print_red_text += level_padding + "'" + item + '\' => "' + value + '"\n'
    }
  } else print_red_text = '===>' + arr + '<===(' + typeof arr + ')'
  return print_red_text
}
